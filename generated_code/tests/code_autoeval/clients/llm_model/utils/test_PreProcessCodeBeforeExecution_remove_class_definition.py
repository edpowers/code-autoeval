# Updated Implementation of PreProcessCodeBeforeExecution.remove_class_definition function
import re


class PreProcessCodeBeforeExecution:
    def remove_class_definition(self, code: str, class_name: str) -> str:
        if f"class {class_name}" in code:
            # Remove actual class definition
            pattern = rf"\s*class\s+{re.escape(class_name)}\s*(\([^)]*\))?\s*:"
            code = re.sub(pattern, "", code)

        # Check if there's still a class definition (which might be a patched recreation)
        remaining_class_def = re.search(
            rf"\s*class\s+{re.escape(class_name)}\s*(\([^)]*\))?\s*:", code
        )
        if remaining_class_def:
            # If it's within a patch or mock context, it's okay
            patch_context = re.search(
                rf"(@patch|mock\.patch|with\s+patch)[^\n]*\n\s*class\s+{re.escape(class_name)}",
                code,
            )
            if not patch_context:
                raise ValueError(
                    f"Unexpected class definition for {class_name} found in the pytest tests."
                )

        if f"class {class_name}" in code:
            raise ValueError(
                f"Class definition for {class_name} found in the pytest tests."
            )

        return code


import re
from unittest.mock import patch

import pytest

# Sample class name for testing
SAMPLE_CLASS_NAME = "SampleClass"


@pytest.fixture
def sample_code():
    return """
class SampleClass:
    def method(self):
        pass

print("Hello, World!")
"""


def test_remove_class_definition_normal(sample_code):
    preprocessor = PreProcessCodeBeforeExecution()
    result = preprocessor.remove_class_definition(sample_code, SAMPLE_CLASS_NAME)
    assert f"class {SAMPLE_CLASS_NAME}" not in result


def test_remove_class_definition_not_present(sample_code):
    preprocessor = PreProcessCodeBeforeExecution()
    result = preprocessor.remove_class_definition(sample_code, "NonExistentClass")
    assert f"class NonExistentClass" not in result


def test_remove_class_definition_within_patch(sample_code):
    with patch(
        "code_autoeval.llm_model.utils.preprocess_code_before_execution.PreProcessCodeBeforeExecution"
    ):
        preprocessor = PreProcessCodeBeforeExecution()
        result = preprocessor.remove_class_definition(sample_code, SAMPLE_CLASS_NAME)
    assert f"class {SAMPLE_CLASS_NAME}" not in result


def test_remove_class_definition_within_mock_context(sample_code):
    with patch(
        "code_autoeval.llm_model.utils.preprocess_code_before_execution.PreProcessCodeBeforeExecution"
    ):
        preprocessor = PreProcessCodeBeforeExecution()
        result = preprocessor.remove_class_definition(sample_code, SAMPLE_CLASS_NAME)
    assert f"class {SAMPLE_CLASS_NAME}" not in result


def test_remove_class_definition_error_condition():
    preprocessor = PreProcessCodeBeforeExecution()
    with pytest.raises(ValueError):
        preprocessor.remove_class_definition(
            "class SampleClass:\n    pass", SAMPLE_CLASS_NAME
        )


class SampleClass:
    def method(self):
        pass


print("Hello, World!")

print("Hello, World!")
